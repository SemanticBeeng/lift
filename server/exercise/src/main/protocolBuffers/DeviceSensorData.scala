// Generated by ScalaBuff, the Scala Protocol Buffers compiler. DO NOT EDIT!
// source: deviceSensorData.proto

final case class MultipleDeviceSensorData (
	`singleDeviceSensorData`: scala.collection.immutable.Seq[MultipleDeviceSensorData.SingleDeviceSensorData] = Vector.empty[MultipleDeviceSensorData.SingleDeviceSensorData]
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[MultipleDeviceSensorData]
	with net.sandrogrzicic.scalabuff.Parser[MultipleDeviceSensorData] {

	def setSingleDeviceSensorData(_i: Int, _v: MultipleDeviceSensorData.SingleDeviceSensorData) = copy(`singleDeviceSensorData` = `singleDeviceSensorData`.updated(_i, _v))
	def addSingleDeviceSensorData(_f: MultipleDeviceSensorData.SingleDeviceSensorData) = copy(`singleDeviceSensorData` = `singleDeviceSensorData` :+ _f)
	def addAllSingleDeviceSensorData(_f: MultipleDeviceSensorData.SingleDeviceSensorData*) = copy(`singleDeviceSensorData` = `singleDeviceSensorData` ++ _f)
	def addAllSingleDeviceSensorData(_f: TraversableOnce[MultipleDeviceSensorData.SingleDeviceSensorData]) = copy(`singleDeviceSensorData` = `singleDeviceSensorData` ++ _f)

	def clearSingleDeviceSensorData = copy(`singleDeviceSensorData` = Vector.empty[MultipleDeviceSensorData.SingleDeviceSensorData])

	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		for (_v <- `singleDeviceSensorData`) output.writeMessage(1, _v)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		for (_v <- `singleDeviceSensorData`) __size += computeMessageSize(1, _v)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): MultipleDeviceSensorData = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		val __singleDeviceSensorData: scala.collection.mutable.Buffer[MultipleDeviceSensorData.SingleDeviceSensorData] = `singleDeviceSensorData`.toBuffer

		def __newMerged = MultipleDeviceSensorData(
			Vector(__singleDeviceSensorData: _*)
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __singleDeviceSensorData += readMessage[MultipleDeviceSensorData.SingleDeviceSensorData](in, MultipleDeviceSensorData.SingleDeviceSensorData.defaultInstance, _emptyRegistry)
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: MultipleDeviceSensorData) = {
		MultipleDeviceSensorData(
			`singleDeviceSensorData` ++ m.`singleDeviceSensorData`
		)
	}

	def getDefaultInstanceForType = MultipleDeviceSensorData.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object MultipleDeviceSensorData {
	@reflect.BeanProperty val defaultInstance = new MultipleDeviceSensorData()

	def parseFrom(data: Array[Byte]): MultipleDeviceSensorData = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): MultipleDeviceSensorData = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): MultipleDeviceSensorData = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): MultipleDeviceSensorData = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[MultipleDeviceSensorData] = defaultInstance.mergeDelimitedFromStream(stream)

	val SINGLEDEVICESENSORDATA_FIELD_NUMBER = 1

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: MultipleDeviceSensorData) = defaultInstance.mergeFrom(prototype)

	object Source extends net.sandrogrzicic.scalabuff.Enum {
		sealed trait EnumVal extends Value
		val _UNINITIALIZED = new EnumVal { val name = "UNINITIALIZED ENUM VALUE"; val id = -1 }

		val HEAD = new EnumVal { val name = "HEAD"; val id = 0 }
		val NECK = new EnumVal { val name = "NECK"; val id = 1 }
		val SHOULDER = new EnumVal { val name = "SHOULDER"; val id = 2 }
		val CHEST = new EnumVal { val name = "CHEST"; val id = 3 }
		val ARM = new EnumVal { val name = "ARM"; val id = 4 }
		val FOREARM = new EnumVal { val name = "FOREARM"; val id = 5 }
		val HAND = new EnumVal { val name = "HAND"; val id = 6 }
		val WRIST = new EnumVal { val name = "WRIST"; val id = 7 }
		val WAIST = new EnumVal { val name = "WAIST"; val id = 8 }
		val HIP = new EnumVal { val name = "HIP"; val id = 9 }
		val THIGH = new EnumVal { val name = "THIGH"; val id = 10 }
		val CALF = new EnumVal { val name = "CALF"; val id = 11 }
		val ANKLE = new EnumVal { val name = "ANKLE"; val id = 12 }
		val FOOT = new EnumVal { val name = "FOOT"; val id = 13 }

		val HEAD_VALUE = 0
		val NECK_VALUE = 1
		val SHOULDER_VALUE = 2
		val CHEST_VALUE = 3
		val ARM_VALUE = 4
		val FOREARM_VALUE = 5
		val HAND_VALUE = 6
		val WRIST_VALUE = 7
		val WAIST_VALUE = 8
		val HIP_VALUE = 9
		val THIGH_VALUE = 10
		val CALF_VALUE = 11
		val ANKLE_VALUE = 12
		val FOOT_VALUE = 13

		def valueOf(id: Int) = id match {
			case 0 => HEAD
			case 1 => NECK
			case 2 => SHOULDER
			case 3 => CHEST
			case 4 => ARM
			case 5 => FOREARM
			case 6 => HAND
			case 7 => WRIST
			case 8 => WAIST
			case 9 => HIP
			case 10 => THIGH
			case 11 => CALF
			case 12 => ANKLE
			case 13 => FOOT
			case _default => throw new net.sandrogrzicic.scalabuff.UnknownEnumException(_default)
		}
		val internalGetValueMap = new com.google.protobuf.Internal.EnumLiteMap[EnumVal] {
			def findValueByNumber(id: Int): EnumVal = valueOf(id)
		}
	}

	final case class SingleDeviceSensorData (
		`source`: Source.EnumVal = Source._UNINITIALIZED,
		`data`: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY
	) extends com.google.protobuf.GeneratedMessageLite
		with com.google.protobuf.MessageLite.Builder
		with net.sandrogrzicic.scalabuff.Message[SingleDeviceSensorData]
		with net.sandrogrzicic.scalabuff.Parser[SingleDeviceSensorData] {



		def writeTo(output: com.google.protobuf.CodedOutputStream) {
			output.writeEnum(1, `source`)
			output.writeBytes(2, `data`)
		}

		def getSerializedSize = {
			import com.google.protobuf.CodedOutputStream._
			var __size = 0
			__size += computeEnumSize(1, `source`)
			__size += computeBytesSize(2, `data`)

			__size
		}

		def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): SingleDeviceSensorData = {
			import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
			var __source: Source.EnumVal = Source._UNINITIALIZED
			var __data: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY

			def __newMerged = SingleDeviceSensorData(
				__source,
				__data
			)
			while (true) in.readTag match {
				case 0 => return __newMerged
				case 8 => __source = Source.valueOf(in.readEnum())
				case 18 => __data = in.readBytes()
				case default => if (!in.skipField(default)) return __newMerged
			}
			null
		}

		def mergeFrom(m: SingleDeviceSensorData) = {
			SingleDeviceSensorData(
				m.`source`,
				m.`data`
			)
		}

		def getDefaultInstanceForType = SingleDeviceSensorData.defaultInstance
		def clear = getDefaultInstanceForType
		def isInitialized = true
		def build = this
		def buildPartial = this
		def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
		override def getParserForType = this
		def newBuilderForType = getDefaultInstanceForType
		def toBuilder = this
		def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
	}

	object SingleDeviceSensorData {
		@reflect.BeanProperty val defaultInstance = new SingleDeviceSensorData()

		def parseFrom(data: Array[Byte]): SingleDeviceSensorData = defaultInstance.mergeFrom(data)
		def parseFrom(data: Array[Byte], offset: Int, length: Int): SingleDeviceSensorData = defaultInstance.mergeFrom(data, offset, length)
		def parseFrom(byteString: com.google.protobuf.ByteString): SingleDeviceSensorData = defaultInstance.mergeFrom(byteString)
		def parseFrom(stream: java.io.InputStream): SingleDeviceSensorData = defaultInstance.mergeFrom(stream)
		def parseDelimitedFrom(stream: java.io.InputStream): Option[SingleDeviceSensorData] = defaultInstance.mergeDelimitedFromStream(stream)

		val SOURCE_FIELD_NUMBER = 1
		val DATA_FIELD_NUMBER = 2

		def newBuilder = defaultInstance.newBuilderForType
		def newBuilder(prototype: SingleDeviceSensorData) = defaultInstance.mergeFrom(prototype)

	}
}

object DeviceSensorData {
	def registerAllExtensions(registry: com.google.protobuf.ExtensionRegistryLite) {
	}

	private val fromBinaryHintMap = collection.immutable.HashMap[String, Array[Byte] ⇒ com.google.protobuf.GeneratedMessageLite](
		 "MultipleDeviceSensorData" -> (bytes ⇒ MultipleDeviceSensorData.parseFrom(bytes))
	)

	def deserializePayload(payload: Array[Byte], payloadType: String): com.google.protobuf.GeneratedMessageLite = {
		fromBinaryHintMap.get(payloadType) match {
			case Some(f) ⇒ f(payload)
			case None    ⇒ throw new IllegalArgumentException(s"unimplemented deserialization of message payload of type [${payloadType}]")
		}
	}
}
